### **回溯算法解题思路：**

【参考**决策树**的深度遍历，目标数据的**路径集合**】 关键：找到节点，分叉，递归的对应题目含义

```c++
    // 第一步：判断输入或者状态是否非法？【剪枝，不符合的不再向下走】
    if (input/state is invalid) {
        return;
  }
    // 第二步：判读递归是否应当结束? 【到达叶子节点，向上返回】
    if (match condition) {
        return some value;
  }
    // 遍历当前所有可能出现的情况 【分几个叉 for】
    for (int i=start【记录自己走到第几个分叉了】; i<分叉数; i++) {
    //若不同节点的分叉数不同，则可以通过多个条件限制
        //  【solution表示树的路径】
        solution.push(case) 【将这个节点之间的连线进行保存】
        // 递归 【每个叉深度遍历一次】
        result = fn(m) 【路径的集合】
        // 第四步：回溯到上一步 【删除该节点之间的连线】
        solution.pop(case)
    }
**if (find(solution.begin(),solution.end(),nums[i]) != solution.end())
      continue; 可以通过判断进行分支删减
```

### **回溯法解题应用：**

**1、字符串等字母的大小写更换**

​		采用多叉树【**有可能不同节点的分叉不一样，要分开讨论**】的思路，迭代，【**分叉**，要进行不同的迭代情况】

**2、N皇后问题**

